---
description: 
globs: 
alwaysApply: true
---
# NestJS Blog Project - Development Rules

## Project Structure

This is a NestJS application with GraphQL and Prisma. Follow this exact directory structure:

```
src/
├── main.ts
├── app.module.ts
│
├── modules/                    # Feature modules (business logic)
│   ├── user/
│   │   ├── user.module.ts
│   │   ├── user.service.ts
│   │   ├── user.resolver.ts
│   │   ├── dto/
│   │   │   ├── create-user.input.ts
│   │   │   ├── update-user.input.ts
│   │   │   └── index.ts
│   │   └── entities/
│   │       ├── user.entity.ts
│   │       └── index.ts
│   ├── auth/
│   │   ├── auth.module.ts
│   │   ├── auth.service.ts
│   │   ├── auth.resolver.ts
│   │   ├── jwt.strategy.ts
│   │   └── types/
│   │       ├── auth.types.ts
│   │       └── index.ts
│   └── [feature]/
│       ├── [feature].module.ts
│       ├── [feature].service.ts
│       ├── [feature].resolver.ts
│       ├── dto/
│       └── entities/
│
├── prisma/                     # Prisma database layer
│   ├── schema.prisma
│   ├── prisma.service.ts
│   ├── prisma.module.ts
│   ├── soft-delete.middleware.ts
│   └── seed.ts
│
├── common/                     # Shared utilities and middleware
│   ├── guards/
│   │   ├── jwt-auth.guard.ts
│   │   ├── global-auth.guard.ts
│   │   └── throttler.guard.ts
│   ├── interceptors/
│   ├── middleware/
│   │   └── logger.middleware.ts
│   ├── filters/
│   ├── scalars/
│   └── helpers.ts
│
├── cron/                       # Scheduled jobs
│   ├── cron.module.ts
│   ├── cron.service.ts
│   └── jobs/
│       ├── clean-temp-files.job.ts
│       └── send-notifications.job.ts
│
├── config/                     # Configuration files
│   ├── database.config.ts
│   ├── jwt.config.ts
│   ├── security.config.ts
│   └── index.ts
│
└── shared/                     # Base classes and abstract services
    ├── base.service.ts
    ├── base.resolver.ts
    ├── decorators/
    │   └── current-user.decorator.ts
    ├── services/
    │   └── security.service.ts
    ├── guards/
    └── schema/
        ├── schema-loader.service.ts
        └── schema.module.ts
```

## File Naming Conventions

- **Modules**: `[feature].module.ts`
- **Services**: `[feature].service.ts`
- **Resolvers**: `[feature].resolver.ts`
- **DTOs**: `create-[feature].input.ts`, `update-[feature].input.ts`
- **Entities**: `[feature].entity.ts`
- **Guards**: `[feature].guard.ts`
- **Middleware**: `[feature].middleware.ts`
- **Jobs**: `[feature].job.ts`

## Import Path Conventions

### Path Aliases (Preferred)
Use path aliases for cleaner, more maintainable imports:

```typescript
// From modules to prisma
import { PrismaService } from '@prisma/prisma.service';
import { PrismaModule } from '@prisma/prisma.module';

// From modules to common
import { JwtAuthGuard } from '@common/guards/jwt-auth.guard';
import { GlobalAuthGuard } from '@common/guards/global-auth.guard';
import { helpers } from '@common/helpers';

// From modules to shared
import { BaseService } from '@shared/base.service';
import { SecurityService } from '@shared/services/security.service';
import { CurrentUser } from '@shared/decorators/current-user.decorator';

// From modules to config
import { ConfigService } from '@nestjs/config';

// From modules to cron
import { CronService } from '@cron/cron.service';

// Cross-module imports
import { UserService } from '@modules/user/user.service';
import { AuthService } from '@modules/auth/auth.service';
```

### Relative Imports (within same module only)
```typescript
// Only use relative imports within the same module
import { UserService } from './user.service';
import { CreateUserInput } from './dto';
import { User } from './entities';
```

## Coding Standards

### 1. Service Pattern
```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '@prisma/prisma.service';

@Injectable()
export class FeatureService {
  constructor(private prisma: PrismaService) {}

  async findAll() {
    const items = await this.prisma.feature.findMany({});
    return items.map(item => {
      const { sensitiveField, ...result } = item;
      return result;
    });
  }

  async findOne(id: number) {
    const item = await this.prisma.feature.findUnique({
      where: { id },
    });
    if (!item) {
      throw new NotFoundException(`Feature with ID ${id} not found`);
    }
    const { sensitiveField, ...result } = item;
    return result;
  }

  async create(createDto: any) {
    const item = await this.prisma.feature.create({
      data: createDto,
    });
    const { sensitiveField, ...result } = item;
    return result;
  }

  async update(id: number, updateDto: any) {
    const item = await this.prisma.feature.update({
      where: { id },
      data: updateDto,
    });
    const { sensitiveField, ...result } = item;
    return result;
  }

  async remove(id: number) {
    const item = await this.prisma.feature.update({
      where: { id },
      data: { deletedAt: new Date() },
    });
    const { sensitiveField, ...result } = item;
    return result;
  }
}
```

### 2. Resolver Pattern
```typescript
import { Resolver, Query, Mutation, Args, Int } from '@nestjs/graphql';
import { UseGuards } from '@nestjs/common';
import { FeatureService } from './feature.service';
import { JwtAuthGuard } from '@common/guards/jwt-auth.guard';

@Resolver()
export class FeatureResolver {
  constructor(private readonly featureService: FeatureService) {}

  @Query()
  @UseGuards(JwtAuthGuard)
  async features() {
    return this.featureService.findAll();
  }

  @Query()
  @UseGuards(JwtAuthGuard)
  async feature(@Args('id', { type: () => Int }) id: number) {
    return this.featureService.findOne(id);
  }

  @Mutation()
  @UseGuards(JwtAuthGuard)
  async createFeature(@Args('createFeatureInput') createFeatureInput: any) {
    return this.featureService.create(createFeatureInput);
  }

  @Mutation()
  @UseGuards(JwtAuthGuard)
  async updateFeature(
    @Args('id', { type: () => Int }) id: number,
    @Args('updateFeatureInput') updateFeatureInput: any,
  ) {
    return this.featureService.update(id, updateFeatureInput);
  }

  @Mutation()
  @UseGuards(JwtAuthGuard)
  async removeFeature(@Args('id', { type: () => Int }) id: number) {
    return this.featureService.remove(id);
  }
}
```

### 3. Module Pattern
```typescript
import { Module } from '@nestjs/common';
import { FeatureService } from './feature.service';
import { FeatureResolver } from './feature.resolver';
import { PrismaModule } from '@prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  providers: [FeatureService, FeatureResolver],
  exports: [FeatureService],
})
export class FeatureModule {}
```

### 4. DTO Pattern
```typescript
import { InputType, Field } from '@nestjs/graphql';

@InputType()
export class CreateFeatureInput {
  @Field()
  name: string;

  @Field()
  description: string;

  @Field({ nullable: true })
  optionalField?: string;
}

@InputType()
export class UpdateFeatureInput {
  @Field(() => Int)
  id: number;

  @Field({ nullable: true })
  name?: string;

  @Field({ nullable: true })
  description?: string;
}
```

### 5. Entity Pattern
```typescript
import { ObjectType, Field, Int } from '@nestjs/graphql';

@ObjectType()
export class Feature {
  @Field(() => Int)
  id: number;

  @Field()
  name: string;

  @Field()
  description: string;

  @Field()
  createdAt: Date;

  @Field()
  updatedAt: Date;

  @Field({ nullable: true })
  deletedAt?: Date;

  // Do not expose sensitive fields in GraphQL
  sensitiveField?: string;
}
```

## Security Patterns

### 1. Password Handling
```typescript
import * as bcrypt from 'bcrypt';

// Hash password before saving
const hashedPassword = await bcrypt.hash(password, 10);

// Compare password for authentication
const isValid = await bcrypt.compare(password, hashedPassword);
```

### 2. JWT Authentication
```typescript
// In JWT Strategy
async validate(payload: any) {
  const user = await this.prisma.user.findUnique({
    where: { id: payload.sub },
  });
  return user;
}
```

### 3. Resource Access Control
```typescript
// Use SecurityService for access control
import { SecurityService } from '@shared/services/security.service';

validateResourceAccess(user: any, resourceOwnerId: number): void {
  this.validateAuthentication(user);
  
  if (!this.canAccessResource(user, resourceOwnerId)) {
    throw new ForbiddenException('Access denied. You can only access your own resources.');
  }
}
```

## Database Patterns

### 1. Soft Delete
```typescript
// Use soft delete middleware for all models with deletedAt field
// The middleware automatically filters out soft-deleted records
```

### 2. Prisma Service Pattern
```typescript
@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
  constructor(private configService: ConfigService) {
    super({
      datasources: {
        db: {
          url: configService.get<string>('database.url'),
        },
      },
    });
  }

  async onModuleInit() {
    await this.$connect();
    this.$use(softDeleteMiddleware());
  }
  
  async onModuleDestroy() {
    await this.$disconnect();
  }
}
```

## Configuration Pattern

### 1. Environment-based Config
```typescript
import { registerAs } from '@nestjs/config';

export default registerAs('feature', () => ({
  setting1: process.env.FEATURE_SETTING1 || 'default',
  setting2: parseInt(process.env.FEATURE_SETTING2 || '100'),
}));
```

### 2. Config Usage
```typescript
constructor(private configService: ConfigService) {}

// Access config
const setting = this.configService.get<string>('feature.setting1');
```

## Error Handling

### 1. Standard Exceptions
```typescript
import { NotFoundException, UnauthorizedException, ForbiddenException } from '@nestjs/common';

// Not found
throw new NotFoundException(`Resource with ID ${id} not found`);

// Authentication
throw new UnauthorizedException('Authentication required');

// Authorization
throw new ForbiddenException('Access denied');
```

### 2. Custom Error Messages
```typescript
// Be specific and user-friendly
throw new Error('User with this email already exists');
```

## Documentation Standards

### 1. JSDoc Comments
```typescript
/**
 * Validate user authentication
 * @param user - The user object from request
 * @throws UnauthorizedException if user is not authenticated
 */
validateAuthentication(user: any): void {
  if (!user) {
    throw new UnauthorizedException('Authentication required');
  }
}
```

### 2. Type Definitions
```typescript
// Always define interfaces for complex types
export interface JwtPayload {
  email: string;
  sub: number;
}

export interface LoginResponse {
  access_token: string;
  user: {
    id: number;
    email: string;
    name: string;
  };
}
```

## Testing Guidelines

### 1. Test File Structure
```
src/modules/[feature]/
├── [feature].service.spec.ts
├── [feature].resolver.spec.ts
└── [feature].module.spec.ts
```

### 2. Test Patterns
```typescript
describe('FeatureService', () => {
  let service: FeatureService;
  let prismaService: PrismaService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        FeatureService,
        {
          provide: PrismaService,
          useValue: {
            feature: {
              findMany: jest.fn(),
              findUnique: jest.fn(),
              create: jest.fn(),
              update: jest.fn(),
            },
          },
        },
      ],
    }).compile();

    service = module.get<FeatureService>(FeatureService);
    prismaService = module.get<PrismaService>(PrismaService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
```

## Performance Guidelines

### 1. Database Queries
- Use Prisma's `select` to limit fields
- Use `include` for relations when needed
- Avoid N+1 queries with proper includes

### 2. Caching
- Implement caching for frequently accessed data
- Use Redis for distributed caching

### 3. Pagination
```typescript
async findAll(page: number = 1, limit: number = 10) {
  const skip = (page - 1) * limit;
  return this.prisma.feature.findMany({
    skip,
    take: limit,
    orderBy: { createdAt: 'desc' },
  });
}
```

## Git Commit Guidelines

### 1. Commit Message Format
```
type(scope): description

feat(user): add user registration endpoint
fix(auth): resolve JWT token validation issue
docs(readme): update installation instructions
refactor(service): extract common validation logic
test(user): add unit tests for user service
```

### 2. Branch Naming
```
feature/user-authentication
bugfix/jwt-validation
hotfix/security-patch
```

## Environment Variables

### 1. Required Environment Variables
```env
DATABASE_URL=postgresql://user:password@localhost:5432/blog
JWT_SECRET=your-super-secret-jwt-key
JWT_EXPIRES_IN=1d
THROTTLE_TTL=60000
THROTTLE_LIMIT=10
```

### 2. Optional Environment Variables
```env
NODE_ENV=development
PORT=3000
LOG_LEVEL=info
```

## Package.json Scripts

### 1. Development Scripts
```json
{
  "scripts": {
    "build": "nest build",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs}/**/*.ts\" --fix",
    "format": "prettier --write \"src/**/*.ts\"",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage"
  }
}
```

### 2. Database Scripts
```json
{
  "scripts": {
    "db:migrate": "prisma migrate dev",
    "db:generate": "prisma generate",
    "db:studio": "prisma studio",
    "db:seed": "ts-node --transpile-only src/prisma/seed.ts"
  }
}
```

## Best Practices Summary

1. **Always use path aliases for cross-module imports**
2. **Use relative imports only within the same module**
3. **Never expose sensitive fields in GraphQL entities**
4. **Use soft delete for all entities**
5. **Implement proper error handling with specific messages**
6. **Use guards for authentication and authorization**
7. **Follow the established naming conventions**
8. **Write comprehensive JSDoc comments**
9. **Use TypeScript interfaces for all complex types**
10. **Implement proper validation in DTOs**
11. **Use the SecurityService for access control**
12. **Follow the established service/resolver patterns**
13. **Use environment variables for configuration**
14. **Implement proper logging and error tracking**
15. **Write unit tests for all services and resolvers**
16. **Use proper Git commit messages and branch naming**

## Common Patterns to Avoid

1. **Don't use relative imports for cross-module dependencies**
2. **Don't expose passwords or sensitive data in GraphQL**
3. **Don't use any type without proper validation**
4. **Don't skip error handling**
5. **Don't hardcode configuration values**
6. **Don't create circular dependencies**
7. **Don't use global variables**
8. **Don't skip input validation**
9. **Don't use console.log in production code**
10. **Don't commit sensitive data to version control**

