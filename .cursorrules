# Cursor Rules for NestJS Blog Project

## Project Overview

This is a **NestJS Blog API** with modular architecture featuring:
- **Core modules** (`src/core/`) - Essential business functionality (auth, users, permissions, audit)
- **Feature modules** (`src/modules/`) - Domain-specific features
- **Dynamic module loading** - Automatic module discovery
- **Modular Prisma schemas** - Each core module has its own `.prisma` file
- **CLI system** with nest-commander for database management
- **GraphQL API** with JWT authentication and RBAC

## Detailed Rules

For complete rules, refer to these organized files:
- **Architecture**: `.cursor/rules/architecture.mdc` - Module boundaries, structure, dependencies
- **Database**: `.cursor/rules/database.mdc` - Prisma schemas, migrations, repository patterns
- **CLI**: `.cursor/rules/cli.mdc` - Command patterns and database management

## Key Principles

### 1. üèóÔ∏è Architecture Rules
- **Core modules** (`src/core/`) contain business-critical functionality
- **Feature modules** (`src/modules/`) contain domain-specific features  
- **Common utilities** (`src/common/`) contain shared infrastructure
- **No circular dependencies** - Dependencies flow downward only
- **Dynamic loading** - Modules auto-discovered, no manual imports in app.module.ts

### 2. üóÑÔ∏è Database Rules
- **Modular schemas** - Each core module has `[module].prisma` file
- **Schema merging** - Always run `yarn run db` before Prisma operations
- **Service-only pattern** - Services use Prisma directly, no repository abstraction
- **Migrations** - Use descriptive names, always test, merge schemas first

### 3. üìÅ File Naming Conventions
- **Services**: `*.service.ts`
- **Modules**: `*.module.ts`
- **DTOs**: `*.input.ts`, `*.args.ts`
- **Commands**: `*.command.ts`
- **Schemas**: `[module-name].prisma`
- **Guards**: `*.guard.ts`
- **Interceptors**: `*.interceptor.ts`

### 4. üì¶ Import Rules
```typescript
// ‚úÖ Use path aliases
import { UserService } from '@core/users';
import { PrismaService } from '@common/prisma';

// ‚ùå Avoid relative paths (except in CLI)
import { UserService } from '../../core/users/user.service';

// Import order: Node modules ‚Üí Internal modules ‚Üí Types
```

### 5. üîß Module Structure (REQUIRED)
Each module MUST have:
```
module-name/
‚îú‚îÄ‚îÄ *.service.ts      # Business logic + data access
‚îú‚îÄ‚îÄ *.module.ts       # NestJS module
‚îú‚îÄ‚îÄ dto/              # Input/output types
‚îú‚îÄ‚îÄ index.ts          # Public API exports
‚îî‚îÄ‚îÄ *.prisma          # Schema (core modules only)
```

### 6. üõ°Ô∏è Security Patterns
```typescript
// Authentication & Authorization
@UseGuards(JwtGuard, PermissionGuard)
@RequirePermissions('user:create')
async createUser() {}

// Error handling
throw new NotFoundException(`User with ID ${id} not found`);
throw new ConflictException('Email already exists');

// Audit logging
await this.auditService.logUserAction(userId, 'CREATE', 'user', newUser.id);
```

### 7. üóÑÔ∏è Database Patterns
```typescript
// Service-only pattern (recommended)
@Injectable()
export class UserService {
  constructor(private prisma: PrismaService) {}
  
  async findById(id: number): Promise<User | null> {
    return this.prisma.user.findUnique({ where: { id } });
  }
  
  async create(data: CreateUserInput): Promise<User> {
    // Business logic + data access in one place
    const existing = await this.prisma.user.findUnique({
      where: { email: data.email }
    });
    if (existing) throw new ConflictException('Email exists');
    
    return this.prisma.user.create({ data });
  }
}

// Interface pattern (for external services only)
export interface IEmailService {
  sendWelcome(user: User): Promise<void>;
}

@Injectable()
export class EmailService implements IEmailService {
  async sendWelcome(user: User): Promise<void> {
    // Implementation
  }
}
```

### 8. üîß CLI Commands
```bash
# Unified database sync (recommended)
yarn run db                  # Merge schemas + generate client
yarn run db users            # Sync only users module
yarn run db core/audit       # Sync only audit from core

# Specific commands
yarn run cli db merge        # Merge schemas only
yarn run cli db generate     # Generate client only
yarn run cli db migrate      # Run migrations
yarn run cli db studio       # Open Prisma Studio
```

### 9. üìä Logging Standards
```typescript
// Structured logging with emojis
this.logger.log('‚úÖ Operation completed successfully');
this.logger.warn('‚ö†Ô∏è Warning message');
this.logger.error('‚ùå Error occurred');

// Include context
this.logger.log(`User ${userId} created successfully`);
```

### 10. üß™ Testing Patterns
```typescript
describe('UserService', () => {
  let service: UserService;
  let prisma: PrismaService;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [
        UserService,
        {
          provide: PrismaService,
          useValue: {
            user: {
              findUnique: jest.fn(),
              create: jest.fn(),
            },
          },
        },
      ],
    }).compile();
    
    service = module.get<UserService>(UserService);
    prisma = module.get<PrismaService>(PrismaService);
  });

  it('should create user successfully', async () => {
    // Arrange, Act, Assert pattern
  });
});
```

## Current Project State

**Existing core modules**:
- `auth/` - JWT authentication
- `users/` - User management
- `permissions/` - Role-based access control  
- `audit/` - Activity tracking

**Database schemas**:
- `src/core/users/users.prisma`
- `src/core/permissions/permissions.prisma`
- `src/core/audit/audit.prisma`
- `prisma/base.prisma` (business models like Post)

**CLI system**: nest-commander based with database management commands

**Dependencies**: NestJS + Prisma + GraphQL + JWT + bcrypt + nest-commander

## AI Assistant Guidelines

When generating code:
1. **Follow modular architecture** - Respect core/feature/common boundaries
2. **Use service-only pattern** - Services use Prisma directly, no repository abstraction
3. **Include proper validation** - DTOs, guards, exception handling
4. **Consider security** - Authentication, authorization, audit logging
5. **Follow naming conventions** - File names, class names, database tables
6. **Use the CLI system** - For database operations, schema merging
7. **Maintain type safety** - Interfaces for external services only
8. **Include tests** - Unit tests for services, mock PrismaService
9. **Document appropriately** - JSDoc for APIs, clear variable names
10. **Performance considerations** - Pagination, indexing, query optimization 